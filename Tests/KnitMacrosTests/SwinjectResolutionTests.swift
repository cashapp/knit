//
// Copyright Â© Block, Inc. All rights reserved.
//

import Foundation
import Swinject
import XCTest
import Knit
import KnitMacros

final class SwinjectResolutionTests: XCTestCase {
    
    func test_simple_service() {
        let container = Factory.container
        container.register(Service1.self, factory: Service1.make)
        XCTAssertNotNil(container.resolve(Service1.self))
    }
    
    func test_resolve_closure() {
        let container = Factory.container
        container.register(Service2.self, factory: Service2.make)
        XCTAssertNotNil(container.resolve(Service2.self))
    }
    
    func test_default_value() {
        let emptyContainer = SwinjectContainer()
        emptyContainer.register(Service3.self, factory: Service3.make)
        let defaultedService = emptyContainer.resolve(Service3.self)
        XCTAssertEqual(defaultedService?.value, 2)
    }

    func test_argument() {
        let container = SwinjectContainer()
        container.register(Service4.self, factory: Service4.make)
        
        let service = container.resolve(Service4.self, argument: Float(5))
        XCTAssertEqual(service?.value, 5)
    }
    
    func test_named_parameter() {
        let container = SwinjectContainer()
        container.register(Float.self, name: "float2") { _ in 2}
        container.register(Service5.self, factory: Service5.make)
        
        let service = container.resolve(Service5.self)
        XCTAssertEqual(service?.value, 2)
    }

    func test_static_function() {
        let container = SwinjectContainer()
        container.register(Service3.self, factory: Service3.makeService(resolver:))

        let service = container.resolve(Service3.self)
        XCTAssertEqual(service?.value, 5)
    }
}

private struct Service1 {
    
    let string: String
    let value: Int
    
    @Resolvable<SwinjectResolver>
    init(string: String, value: Int) {
        self.string = string
        self.value = value
    }
}

private struct Service2 {
    let closure: () -> Void
    
    @Resolvable<SwinjectResolver>
    init(closure: @escaping () -> Void) {
        self.closure = closure
    }
}

private struct Service3 {
    
    let value: Int
    
    @Resolvable<SwinjectResolver>
    init(@UseDefault defaultedValue: Int = 2) {
        self.value = defaultedValue
    }

    @Resolvable<SwinjectResolver>
    static func makeService() -> Service3 {
        return .init(defaultedValue: 5)
    }
}

private struct Service4 {
    let value: Float
    @Resolvable<SwinjectResolver>
    init(@Argument value: Float) {
        self.value = value
    }
}

private struct Service5 {
    let value: Float
    @Resolvable<SwinjectResolver>
    init(@Named("float2") value: Float) {
        self.value = value
    }
}

private enum Factory {
    static var container: SwinjectContainer {
        let container = SwinjectContainer()
        container.register(String.self) { _ in "Test" }
        container.register(Int.self) { _ in 5 }
        container.register((()->Void).self) { _ in
            return {
                print("Test")
            }
        }
        
        return container
    }
}

// Resolver functions to match what would be generated by Knit

enum FloatName: String {
    case float2
}

private extension SwinjectResolver {

    func float(name: FloatName) -> Float {
        resolve(Float.self, name: name.rawValue)!
    }
    
    func string() -> String {
        resolve(String.self)!
    }
    
    func int() -> Int {
        resolve(Int.self)!
    }
    
    func closure() -> ()->Void {
        resolve((()->Void).self)!
    }
}
